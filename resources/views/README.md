# [Blade шаблоны](https://laravel.com/docs/9.x/blade#main-content)

Blade является мощнейшим инструментом, для фронтэнд части клиент-серверного приложения. Он позволяет пользоваться и изменять динамический контент непосредственно в HTML разметке. Все файлы отображений обязательно должны быть с расширением ```.blade.php```.

Внутри файлов шаблонов можно получить доступ к любому динамическому полю в ```Request```, просто обратясь к нему в двойных фигурных скобках: ```{{ $variable }}```

## Шаблоны шаблонов

При обычном проектировании веб-ресурсов, зачастую приходится повторять один и тот же код, в нескольких местах, или файлах. Например навигационную панель, футеры, боковые панели и т.д.

Blade предлагает универсальное решение. Создаём два blade файла в папке ```layouts```.

- В файле [app.blade.php](https://github.com/DavidaaWoW/LaravelCarServiceApplication/blob/main/resources/views/layouts/app.blade.php) объявляем стандартную HTML разметку, подключаем все завиимости, а внутри главного элемента контейнера прописываем директиву ```@yield('navbar')```, которая означает, что в данный шаблон возможно встраивание другого контента, по ключу ```navbar```.

- Далее, создаём файл [navbar.blade.php](https://github.com/DavidaaWoW/LaravelCarServiceApplication/blob/main/resources/views/layouts/navbar.blade.php), прописываем директиву ```@extends('layouts.app')```, которая по сути, просто переносит весь контент из предыдущего файла, одной строчкой. Далее, объявляем встраивание контента в указанную секцию navbar: ```@section('navbar')```. В конце, также открываем шаблон для встраивания остального контента: ```@yield('content')```. Закрываем секцию ```@endsection```.

Интернет ресурс был написан с помощью библиотеки [Bootstrap](https://getbootstrap.com/docs/5.2/getting-started/introduction/).

В navbar-е мы как раз впервые и воспользуемся роутингами, в виде вызова прослушек, через их относительный путь, не забывая указать основную группу. Роутинги, также вызываются в двойных фигурных скобках: ```{{ route('user.about') }}```

Про директиву @lang рассказано в разделе [локализации](https://github.com/DavidaaWoW/LaravelCarServiceApplication/tree/main/lang)

Шаблоны шаблонов готовы! Теперь, мы можем просто прописывать весь необходимый контент сразу же в файлах, просто вставляя шаблон navbar-а, получая на выходе скелет разметки и саму навигационную панель.

## Страницы аутентификации

В страницах аутентификации не используются шаблоны шаблонов, так как у них уникальная структура, без навигационной панели.

Интересным же в них является взаимодействие с формами и автоматическая обработка ошибок.

- Формы

В самом теге формы нет ничего необычного, только в действии вызывается не ссылка, или JS функция, а роутинг ```action="{{ route('user.registration') }}"```.

Внутри формы, обязательно прописывается директива [CSRF](https://laravel.com/docs/9.x/csrf#main-content), она отвечает, за валидацию запросов, по сути, создавая внутри формы дополнительный ```input``` с типом ```hidden```, в который помещается уникальный токен, далее считывающийся на стороне сервера. Если эту директиву не поставить, то при попытке передачи данных, laravel выдаст ошибку 419.

- Обработка ошибок

В Blade существует директива ```@error```, которая позволяет отображать ошибки, если страница была вызвана из контроллера с методом ```withErrors```, внутри директивы прописывается ошибка, доступ к содержанию которой появляется по полю ```{{ $message }}```. Директиву необходимо закрыть: ```@enderror```

## Профиль

Из интересного, в профиле можно отметить первое использование шаблонов шаблонов 
```
@extends('layouts.navbar')

@section('content')

...

@endsection
```

В блоке ```licence```, внутрь подаётся переменная ```{{ $licenceBlock }}```. Она отвечает за то, чтобы блок показывался лишь в том случае, если у пользователя загружены в систему права. Передаётся переменная в [AppServiceProvider](https://github.com/DavidaaWoW/LaravelCarServiceApplication/blob/main/app/Providers/AppServiceProvider.php).

[Провайдеры](https://laravel.com/docs/9.x/providers#main-content) отвечают за первоначальную инициализацию и запуск приложения. ```AppServiceProvider``` в данном случае пользуется механизмом [композеров](https://laravel.com/docs/9.x/views#view-composers). Первым параметром передаётся ```view```, в данном случае ```profile```, а вторым, коллбек функция, которая тут инициализируется на месте, но может быть вынесена в отдельный метод композер класса.

Находится пользователь, и если у него поле ```size```, которое отвечает за размер файла не равно нулю, то во ```view``` передаётся параметр ```null```, который по сути в шаблоне профиля будет проигнорирован. А вот если пользователь не загружал файла, то в этот ```view``` уже передаётся параметр ```hidden```, который скрывает конечный блок в шаблоне.

Также, в профиле появляется вызов путей по имени ``` <a href="{{ route('user.downloadPDF') }}">```

Помимо ~~локализации~~ в профиле также присутствует ~~изменение темы пользователей~~, где используется механизм передачи в путь параметров, в данном случае статических ```<a href="{{ route('user.setTheme', 'dark') }}">```

Через профиль также можно загрузить права и выйти из учётной записи.

## Циклы

В файлах, отображающих списки [брендов](https://github.com/DavidaaWoW/LaravelCarServiceApplication/blob/main/resources/views/dynamic1.blade.php) и [автомобилей](https://github.com/DavidaaWoW/LaravelCarServiceApplication/blob/main/resources/views/dynamic2.blade.php) используются циклы. Из [контроллера](https://github.com/DavidaaWoW/LaravelCarServiceApplication/blob/main/app/Http/Controllers/BrandController.php) передаётся массив объектов модели, по которому в шаблонах с помощью директивы ``` @foreach ($brands as $brand)``` происходит итерация по циклу.

Внутри цикла, мы спокойно можем обращаться к полям итерируемого объекта ```<h5 class="card-title">{{ $brand->name }}</h5>```.

Далее, в ссылке на список автомобилей, передаём поле ```brand->id``` внутри запроса ```{{ route('user.dynamic2', ['brand' => $brand->id]) }}```

Директиву цикла также необходимо закрыть ```@endforeach```
